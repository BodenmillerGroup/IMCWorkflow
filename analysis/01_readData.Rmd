---
title: "Data import"
author: "Nils Eling"
output:
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE, message=FALSE)
```

# Data import

Raw image files in .mcd format are processed using the [IMC Segementation Pipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline).
The pipeline creates a number of folders that contain relevant files for image and single-cell data analysis.
For single-cell IMC data analysis, the cell-level intensity values per marker need to be linked to (i) cell- and image-specific metadata, (ii) marker-specific metadata and (iii) neighbourhood information.
These data are commonly stored in following files:

* __cells.csv__ (or similar): contains the cell-level information of a multitude of features. While the majority of these features should be regarded as cell-level metadata (e.g. shape and position), usually the _MeanIntensity_ and __MeanIntensityCorrected__ columns contain the raw and spill-over-corrected counts per cell and per channel.
* __Image.csv__: contains image-level metadata. These include the image name, number of detected cells, and most importantly the scaling factor, with which the counts need to be multiplied to account for the image encoding (e.g. 16-bit images: scaling factor = 2^{16}-1 = 65535).
* __Object Relationships.csv__: contains a table of relationships between neighbouring cells.
* __Panel.csv__: to associate the channel names with the metal-labelled antibodies, the user needs to specify a file that conatins the link between (i) antibody, (ii) metal-tag and (iii) channel name. 

__TODO: more information on how to generate these files using CellProfiler.__ 

The files __cells.csv__, __Image.csv__ and __Object relationships.csv__ can be found in the __cpout__ folder created by the __IMC Segmentation Pipeline__.
However, the location of the __Panel.csv__ file is not controlled and needs to specified by the user.

```{r read-in-data}
cells <- read.csv(file = "data/extdata/cells.csv", stringsAsFactors = FALSE)

image <- read.csv(file = "data/extdata/image.csv", stringsAsFactors = FALSE)

relationships <- read.delim(file = "data/extdata/Object relationships.csv", 
                            stringsAsFactors = FALSE)

panel <- read.csv(file = "data/extdata/panel.csv", stringsAsFactors = FALSE)
```

## Data cleaning

The __cell.csv__ contains `r ncol(cells)` cell-level features.
These include cell-specific intensity counts per marker as well as positional information, object and image identifiers.
These are crucial to link cells to individual images (and image-level metadata) as well as to segmented objects on images.
The `colnames` of the __cells.csv__ file indicates the measured features. 
All channel (marker)-specific intensity features are stored in the format `..._cX`, where X indicates the channel number.   
An overview on which features were acquired can be obtained after excluding the channel ID.

```{r cell-features}
unique( sub("_c[0-9]*$", "", colnames(cells)) )
```

A number of different area, intensity, location and neighbourhood features were selected for export from `CellProfiler`.
For more details on these features, please refer to the manual ([CellProfiler Measurement](https://cellprofiler-manual.s3.amazonaws.com/CellProfiler-3.1.9/modules/measurement.html#)).
To obtain cell-specific intesities for each marker, a number of different measurements are available:

* __IntegratedIntensity__: Sum of pixel intensities across all pixels of each cell
* __MeanIntensity__: Mean pixel intensity across all pixels of each cell
* __MedianIntensity__: Median pixel intensity across all pixels of each cell

Furthermore, these measures can be calculated on different image stacks:

* __FullStack__: Contains the raw pixel intensities 
* __FullStackFiltered__:  Contains the pixel intensities after applying a selective median filter to remove 'hot pixels' (unusually bright pixels)
* __ProbabStack__: Contains the probability for each pixel to be associated with a certain class selected during pixel classification (__Refs!__)

In addition, intensities can corrected for spill-over between channels (__Cell Systems ref__).
This is either done on the pixel- or cell-level intensities.
These cell-level corrected features are either stored as __MeanIntensityCorrectedLS__ using a least-squares regression for correction or _MeanIntensityCorrected_ using a non-negative least-squares regression for correction (__Refs!__)
For our purposes, we will work on the spillover corrected counts averaged across each cell after removing 'hot pixels' (unusually bright pixels). 
Here, spillover-correction was done using a least-squares (`Intensity_MeanIntensityCorrectedLS_FullStackFiltered`) and non-negative least-squares regression (`Intensity_MeanIntensityCorrected_FullStackFiltered`) approach (__Refs!__).
To avoid negative values, we will select the non-negative least-squares corrected counts, which can be accessed via:

```{r, eval=FALSE}
# create an object for each measured variable and for the unique stacks
cells.meanintensity <- cells.mat[,grepl("Intensity_MeanIntensity_FullStackFiltered_", colnames(cells.mat))]
cells.meanintensity.corrected <- cells.mat[,grepl("Intensity_MeanIntensityCorrected_FullStackFiltered_", colnames(cells.mat))]

# scale the count data with the scaling factor stored in image.met
cells.meanintensity = cells.meanintensity * image.mat[, "Scaling_FullStackFiltered"][1]
cells.meanintensity.corrected = cells.meanintensity.corrected * image.mat[, "Scaling_FullStackFiltered"][1]

# channels stored in the "panel.mat" and in the "cells.X" object
panel.channels <- paste0("c", 1:nrow(panel.mat))
cells.channels <- gsub(".*_", "", colnames(cells.meanintensity))

# match channels from the panel and the channels from the measured variable
cells.meanintensity <- cells.meanintensity[,match(panel.channels, cells.channels)]
cells.meanintensity.corrected <- cells.meanintensity.corrected[,match(panel.channels, cells.channels)]
```

# Create a `SingleCellExperiment` object
Now it's time to create your `SCE` object which combines all the different facets of your data.
For each measured variable, there will be a separate `assay` in the object. 

```{r, eval=FALSE, message=FALSE}
library(SingleCellExperiment)
# Build the SingleCellExperiment object with the different measuretypes (= assays)
sce <- SingleCellExperiment::SingleCellExperiment(assays = list(
  meanintensity=t(cells.meanintensity),
  meanintensity_corrected=t(cells.meanintensity.corrected)))
  
# Build the row metadata
row.data <- DataFrame(row.names = colnames(cells.meanintensity),
                        panel.mat)
  
# Build the column metadata
col.data <- DataFrame(row.names = rownames(cells.meanintensity),
                      image_number = image_number,
                      cell_number = cell_number)
  
# Add these metadata to SCE object
colData(sce) <- col.data
rowData(sce) <- row.data
```

# Add object relationship to the SCE object
[ImcSegmentationPipeline](github.com/BodenmillerGroup/ImcSegmentationPipeline) will furthermore create a file containing relationship information for all the single-cells (neighbours of single-cells). 
We also want this information to be part of our `SingleCellExperiment` object. 
This kind of information can be stored in the `ColDat` of the object. 
Each row represents a cell, each column will contain information for this cell. 
One column is the neighbourhood information, containing IDs of neighbouring cells. 

```{r, eval=FALSE}
#Convert to wide format
relationships.mat = as.data.table(relationships.mat)
relationships.mat <- relationships.mat[, id := paste(.BY,collapse =  "_"), by=.(First.Image.Number,First.Object.Number)]
setkey(relationships.mat ,id)
relationships.mat[, myorder := 1:.N, by = .(id)]
rel_dat_wide = dcast.data.table(relationships.mat,formula = 'First.Image.Number + First.Object.Number ~ myorder', value.var = 'Second.Object.Number')

#Convert to simple list
neighb_lists <- split(rel_dat_wide[,3:ncol(rel_dat_wide)], seq(nrow(rel_dat_wide)))
neighb_lists = lapply(neighb_lists, function(x) unlist(x)[!is.na(x)])
neighb_frame = DataFrame(rel_dat_wide[,1:2],SimpleList(neighb_lists))

# To make sure the order corresponds 
experiment_order = colData(sce)
colnames(experiment_order) = c("First.Image.Number","First.Object.Number")
neighb_frame = neighb_frame[order(match(neighb_frame[,c("First.Image.Number","First.Object.Number")],experiment_order)),]

# add relationship information to SCE object
colData(sce) = DataFrame(colData(sce),neighb_frame)
```

# Save `SingleCellExperiment` Object
```{r, eval=FALSE}
saveRDS(sce, "data/extdata/SingleCellExperiment.rds")
```



