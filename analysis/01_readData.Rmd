---
title: "Data import"
output:
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

# Data import

Raw image files in .mcd format are processed using the [IMC Segementation Pipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline).
The pipeline creates a number of folders that contain relevant files for image and single-cell data analysis.
For single-cell IMC data analysis, the cell-level intensity values per marker need to be linked to (i) cell- and image-specific metadata, (ii) marker-specific metadata and (iii) neighbourhood information.
These data are commonly stored in following files:

* __cells.csv__ (or similar): contains the cell-level information of a multitude of features. While the majority of these features should be regarded as cell-level metadata (e.g. shape and position), usually the _MeanIntensity_ and __MeanIntensityCorrected__ columns contain the raw and spill-over-corrected counts per cell and per channel.
* __Image.csv__: contains image-level metadata. These include the image name, number of detected cells, and most importantly the scaling factor, with which the counts need to be multiplied to account for the image encoding (e.g. 16-bit images: scaling factor = 2^{16}-1 = 65535).
* __Object Relationships.csv__: contains a table of relationships between neighbouring cells.
* __Panel.csv__: to associate the channel names with the metal-labelled antibodies, the user needs to specify a file that conatins the link between (i) antibody, (ii) metal-tag and (iii) channel name. 

__TODO: more information on how to generate these files using CellProfiler.__ 

The files __cells.csv__, __Image.csv__ and __Object relationships.csv__ can be found in the __cpout__ folder created by the __IMC Segmentation Pipeline__.
However, the location of the __Panel.csv__ file is not controlled and needs to specified by the user.

# Load single-cell, image, relationship and meta data

```{r}
# load data 
cells.mat <- read.csv(file = "data/extdata/cells.csv", stringsAsFactors = FALSE)
image.mat <- read.csv(file = "data/extdata/image.csv", stringsAsFactors = FALSE)
relationships.mat <- read.delim(file = "data/extdata/Object_relationships.txt", stringsAsFactors = FALSE)
panel.mat <- read.csv(file = "data/extdata/panel.csv", stringsAsFactors = FALSE)

# extract information from the "cells.mat" object
image_number <- cells.mat$ImageNumber # check if this exists
cell_number <- cells.mat$ObjectNumber # check if this exists
```

# What single-cell variables should be included in the SingleCellExperiment (SCE) object?
[ImcSegmentationPipeline](github.com/BodenmillerGroup/ImcSegmentationPipeline) will measure multiple variables for every object. 
This measurment can also be done on different stacks (e.g. `FullStack`, `FullStackFiltered`, `ProbabStack` etc.). 
A measured single-cell variable is for example the mean intensity per channel. 
Other potential variables are median, maximum, integrated counts etc. 
It is now important to define which variables from which stack should be included in your SCE Object in order to keep your object small and your analyis efficient. 
Create a own object for each measure variable (e.g. `cells.meanintensity`, `cells.meanintensity.corrected`). 
If you want to know what variables are available, use the following command: 
```{r} 
# return unique measure variables/stacks without channels
# sub(...)
colnames(cells.mat)
```
 
```{r, eval=FALSE}
# create an object for each measured variable and for the unique stacks
cells.meanintensity <- cells.mat[,grepl("Intensity_MeanIntensity_FullStackFiltered_", colnames(cells.mat))]
cells.meanintensity.corrected <- cells.mat[,grepl("Intensity_MeanIntensityCorrected_FullStackFiltered_", colnames(cells.mat))]

# scale the count data with the scaling factor stored in image.met
cells.meanintensity = cells.meanintensity * image.mat[, "Scaling_FullStackFiltered"][1]
cells.meanintensity.corrected = cells.meanintensity.corrected * image.mat[, "Scaling_FullStackFiltered"][1]

# channels stored in the "panel.mat" and in the "cells.X" object
panel.channels <- paste0("c", 1:nrow(panel.mat))
cells.channels <- gsub(".*_", "", colnames(cells.meanintensity))

# match channels from the panel and the channels from the measured variable
cells.meanintensity <- cells.meanintensity[,match(panel.channels, cells.channels)]
cells.meanintensity.corrected <- cells.meanintensity.corrected[,match(panel.channels, cells.channels)]
```

# Create a `SingleCellExperiment` object
Now it's time to create your `SCE` object which combines all the different facets of your data.
For each measured variable, there will be a separate `assay` in the object. 

```{r, eval=FALSE, message=FALSE}
library(SingleCellExperiment)
# Build the SingleCellExperiment object with the different measuretypes (= assays)
sce <- SingleCellExperiment::SingleCellExperiment(assays = list(
  meanintensity=t(cells.meanintensity),
  meanintensity_corrected=t(cells.meanintensity.corrected)))
  
# Build the row metadata
row.data <- DataFrame(row.names = colnames(cells.meanintensity),
                        panel.mat)
  
# Build the column metadata
col.data <- DataFrame(row.names = rownames(cells.meanintensity),
                      image_number = image_number,
                      cell_number = cell_number)
  
# Add these metadata to SCE object
colData(sce) <- col.data
rowData(sce) <- row.data
```

# Add object relationship to the SCE object
[ImcSegmentationPipeline](github.com/BodenmillerGroup/ImcSegmentationPipeline) will furthermore create a file containing relationship information for all the single-cells (neighbours of single-cells). 
We also want this information to be part of our `SingleCellExperiment` object. 
This kind of information can be stored in the `ColDat` of the object. 
Each row represents a cell, each column will contain information for this cell. 
One column is the neighbourhood information, containing IDs of neighbouring cells. 

```{r, eval=FALSE}
#Convert to wide format
relationships.mat = as.data.table(relationships.mat)
relationships.mat <- relationships.mat[, id := paste(.BY,collapse =  "_"), by=.(First.Image.Number,First.Object.Number)]
setkey(relationships.mat ,id)
relationships.mat[, myorder := 1:.N, by = .(id)]
rel_dat_wide = dcast.data.table(relationships.mat,formula = 'First.Image.Number + First.Object.Number ~ myorder', value.var = 'Second.Object.Number')

#Convert to simple list
neighb_lists <- split(rel_dat_wide[,3:ncol(rel_dat_wide)], seq(nrow(rel_dat_wide)))
neighb_lists = lapply(neighb_lists, function(x) unlist(x)[!is.na(x)])
neighb_frame = DataFrame(rel_dat_wide[,1:2],SimpleList(neighb_lists))

# To make sure the order corresponds 
experiment_order = colData(sce)
colnames(experiment_order) = c("First.Image.Number","First.Object.Number")
neighb_frame = neighb_frame[order(match(neighb_frame[,c("First.Image.Number","First.Object.Number")],experiment_order)),]

# add relationship information to SCE object
colData(sce) = DataFrame(colData(sce),neighb_frame)
```

# Save `SingleCellExperiment` Object
```{r, eval=FALSE}
saveRDS(sce, "data/extdata/SingleCellExperiment.rds")
```



